---
title: "More Effective C++ 4. 效率"
date: 2022-04-16T18:31:00+08:00
draft: false
tags: ["More Effective C++", "C++"]
slug: "More Effective C++ chapter 4"
---

本文主要为 More Effective C++ 条款 16 - 24 的学习与总结。

目录：

- [条款 16 谨记 80-20 法则](#条款-16-谨记-80-20-法则)
- [条款 17 考虑使用缓式评估](#条款-17-考虑使用缓式评估)
- [条款 18 分期摊还预期的计算成本](#条款-18-分期摊还预期的计算成本)
- [条款 19 了解临时对象的来源](#条款-19-了解临时对象的来源)
- [条款 20 协助完成 “返回值优化”](#条款-20-协助完成-返回值优化)
- [条款 21 利用重载技术避免隐式类型转换](#条款-21-利用重载技术避免隐式类型转换)
- [条款 22 考虑以操作符复合形式（op=）取代其独身形式（op）](#条款-22-考虑以操作符复合形式op取代其独身形式op)
- [条款 23 考虑使用其他程序库](#条款-23-考虑使用其他程序库)
- [条款 24 了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本](#条款-24-了解-virtual-functionsmultiple-inheritancevirtual-base-classesruntime-type-identification-的成本)
- [参考资料](#参考资料)

## 条款 16 谨记 80-20 法则

**基本重点：** 软件的整体性能几乎总是由其构成要素（代码）的一小部分决定。

**找出性能瓶颈的正确做法：** 完全根据观察或实验（通过程序分析器）来进行识别。同时为确保识别瓶颈的准确性，应该尽可能地以最多的数据来分析软件，且保证测试数据对于客户而言可重制。

## 条款 17 考虑使用缓式评估

**缓式评估（lazy evaluation）：** 以某种方式撰写 classes，使它们延缓运算，直到那些运算结果刻不容缓地被迫切需要为止。如果其运算结果一直不被需要，运算也就一直不执行。

**常见用途及优点：**

* 引用计数（Reference Counting）
  * 在真正需要之前，不必为某物做一个副本，而是共享同一副本的值，并做一些记录工作（如：引用计数）记录哪些对象共享了这一内容。
  * 优点：避免非必要的对象复制。
* 区分读和写
  * 区分读和写，并对两者执行不同的操作，因为读操作通常比写操作代价更为低廉。运用缓式评估可以帮助延缓决定究竟是读还是写。
  * 优点：区别 `operator[]` 的读取和写动作。
* 缓式取出（Lazy Fetching）
  * 在产生一个对象时，仅产生该对象的 “外壳”，不从磁盘读取任何字段数据。当对象内的某个字段被需要了，程序才从数据库中取回对应的数据。
  * 优点：避免非必要的数据库读取动作。
* 表达式缓评估（Lazy Expression Evalution）
  * 直到需要确切知道其结果矩阵中的哪一部分被真正需要，然后再做那一部分计算（如：矩阵乘法）。
  * 优点：避免非必要的数值计算动作。

**缓式评估缺点：**

如果计算是必须的，那么缓式评估并不会节省任何工作或时间。相反，程序还需额外处理为缓式评估而设计的数据结构，导致程序效率降低。

**实践方法：**

* 首先通过急式评估（立即计算出结果）策略实现 class。
* 通过分析报告（参见条款 ME16）确定该 class 为性能瓶颈之后，再以另一个实行缓式评估的 class 进行取代。

## 条款 18 分期摊还预期的计算成本

**超急评估（over-eager evaluation）：** 超前进度地做 “要求以外” 的更多工作。

**理念：** 如果预期程序常常会用到某个计算，那么可以通过设计一种数据结构有效率地处理需求，并降低每次计算的平均成本。

**常见实现方法：**

* 高速缓存（Cache）：
  * 将已经计算好而有可能再被需要的数值保留下来。
  * 常见应用：用 内存数据结构（如：map）查找动作 取代 相对昂贵的数据库查询动作。
* 预先取出（Prefetch）：
  * 预先取出一大块数据比分成两三次每次读取小块数据速度更快。
  * 常见应用：vector 扩容机制。

## 条款 19 了解临时对象的来源

**临时对象：** 一个 non-heap 对象，且未命名。

**临时对象通常发生于以下两种情况：**

* **隐式类型转换被施行起来以求函数调用能够成功。**
  * 发生时机：传递对象给一个函数，而其类型与它即将绑定上去的参数类型不同。
  * 发生动作：将实际入参对象作为自变量，调用函数形参所需类型的构造函数，构造一个临时对象绑定到参数上，当函数返回时，此临时对象会被自动销毁。
  * 只有当对象以 by value 方式传递或是对象被传递给一个 reference-to-const 参数时，才会发生上述转换。
  * 如果对象被传递给一个 reference-to-non-const 参数，则不会发生转换，而是会报错。因为创建临时对象与程序员通过引用传递以修改原对象的期望相冲突。
* **函数返回对象时。**
  * 例如：`operator+` 返回运算结果。

临时对象所伴随的构造成本和析构成本可能会对程序性能带来一定的影响，应尽可能地辨别并消除它们。

## 条款 20 协助完成 “返回值优化”

通过返回 constructor arguments 以取代对象，使得编译器能够进行优化，以消除掉临时对象的成本。

```C++
// 建立对象后返回
Object func() {
    Object obj(val);
    return obj;
}

// 返回 constructor arguments
Object func() {
    return Object(val);
}
```

**注：** 目前 C++ 命名对象和匿名对象均可借由 return value optimization 被优化去除，所以在较新的 C++ 标准中上述两个版本均可生成相同（优化过的）的目标代码（obj）。

## 条款 21 利用重载技术避免隐式类型转换

由于隐式类型转换会承受临时对象的成本（参见条款 ME19），为了避免该成本，可采用重载技术。

* 例如：在大部分程序中，如果可以接受一个 `char*`，那么也会希望接受一个 `string` 对象，此时就可以借由重载技术，分别声明入参为 `string` 和 `char*` 的两个函数，消除类型转换。

## 条款 22 考虑以操作符复合形式（op=）取代其独身形式（op）

考虑以操作符复合形式（op=）取代其独身形式（op）。

原因：独身版本通常必须返回一个对象，因此也必须承担一个临时对象的构造与析构成本（参见条款 ME19 ME20）。而复合版本直接将结果写入其左端变量，不需要产生一个临时对象。

## 条款 23 考虑使用其他程序库

不同的程序库即使提供相似的机能，往往也表现出不同的性能取舍策略，故一旦确认了程序的性能瓶颈，可考虑是否存在另一个功能相近而性能较好的程序库，进行替换。例如： I/O 性能上，stdio 库就比 iostreams 库要好。

## 条款 24 了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本

**虚函数（virtual functions）成本：**

* 必须为每个拥有虚函数的 class 耗费一个 virtual table（vtbl）空间，其大小视虚函数的个数（包括继承而来的）而定。
* 必须在每一个拥有虚函数的对象内付出一个额外指针 virtual table pointer（vptr）的代价。
* 事实上放弃了 inline。
  * 因为 inline 意味着 **编译期**，将调用端的调用动作由调用函数的函数本体取代，而 virtual 意味着直到 **运行期** 才知道哪个函数被调用。故 virtual 函数无法进行 inline（除非虚函数通过对象被调用，对象调用可以 inline，但大部分虚函数调用动作为了实现多态，是由指针或引用完成的，所以虚函数事实上等于无法被 inline）。

**多重继承（multiple inheritance）成本：**

* 增加 class 数据量。
* 增加对象大小。

**虚拟基类（virtual base classes）成本：**

* 增加 class 数据量。
* 增加对象大小。

**运行时期类型辨识（runtime type identification，RTTI）成本：**

* 运行时期 objects 和 classes 的相关信息被保存到类型为 type_info 的对象内，可以利用 typeid 操作符获取某个 class 相应的 type_info 对象。
* RTTI 通常根据 class 的 vtbl 实现，其空间成本只需在每一个 class vtbl 内增加一个条目（可能为一个指针，指向该 class 相应的 type_info 对象），再加上每个 class 所需一份 type_info 对象空间。

## 参考资料

* 《More Effective C++：35个改善编程与设计的有效方法》（中文版）
