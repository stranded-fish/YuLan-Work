---
title: "分治算法"
date: 2021-09-23T20:45:00+08:00
draft: false
tags: ["Algorithm"]
slug: "Divide and Conquer"
---

分治，即「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即为子问题的解的合并。分治技巧是很多高效算法的基础，如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）。

目录：

- [递归与分治](#递归与分治)
- [适用场景](#适用场景)
- [基本步骤](#基本步骤)
- [复杂度分析](#复杂度分析)
- [参考链接](#参考链接)

## 递归与分治

分治算法产生的子问题往往与原问题具有相同或类似的结构，原问题和子问题的唯一区别是输入规模的不同，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。

* 递归是一种编程技巧，即函数直接或间接地调用自身，每一层递归调用，传入的参数的值并不完全一样；
* 分治是一种算法设计的思想，绝大部分情况下「分治算法」通过「递归」实现。即：子问题的求解通过递归方法实现。

「递归」函数基于 「自顶向下」拆分问题，再「自底向上」逐层解决问题的思想设计而成，这与「分而治之」的算法思想相同。

> **扩展:** 不仅局限于分治算法，任何在解决问题的过程中涉及到与原问题结构相同的子问题时，都应该想到运用递归技巧（特别是涉及到树、链表等数据结构的问题，因为这类数据结构的子结构：子链表、子树，天生与父结构相同）。同时在调用过程中不必过多考虑跳转到递归函数里的步骤，**而是充分信任递归函数，将其视作功能正确的盲盒，然后站在本层递归的角度思考：**
>
> * 递归的终止条件；
> * 本层递归需要做的事情；
> * 本层递归的返回值。

## 适用场景

分治法能够解决的问题一般具有以下几个特征：

* **分解**（Divide）：该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；
* **解决**（Conquer）：该问题的规模缩小到一定的程度就可以容易地解决；
* **合并**（Combine）：利用该问题分解出的子问题的解可以合并为该问题的解；
  * 如果不具备该特征可以考虑用贪心算法或动态规划。
* 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（非必须）
  * 该特征涉及到分治法的效率，如果分解出来的各个子问题需要重复地解决公共的子问题，此时应考虑动态规划算法，以避免重复计算。

## 基本步骤

在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：

1. **分解**（Divide）步骤将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
2. **解决**（Conquer）步骤递归地求解子问题，若子问题的规模足够小，则停止递归，直接求解；
3. **合并**（Combine）步骤将各个子问题的解合并为原问题的解。

其一般的算法设计模式如下：

```C++
Divide-and-Conquer(P)

// 基本情况（base case）：子问题足够小，可直接求解
1. if |P| ≤ n0

2. then return(ADHOC(P))

// 递归情况（recursive case）：子问题足够大，需要递归求解
3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)
```

* 其中 |P| 表示问题 P 的规模；
* n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。
* ADHOC(P) 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 ADHOC(P) 求解。
* 算法 MERGE(y1,y2,...,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,...,Pk 的相应的解 y1,y2,...,yk 合并为 P 的解。

**「分治思想」的特例是「减治思想（Decrease-and-Conquer）」：每一步将问题转换成为规模更小的子问题。**「减治思想」思想的典型应用是「二分查找」「选择排序」「插入排序」「快速排序」算法。

「分治思想」与「减治思想」的区别如下：

* 分治思想：将一个问题拆分成若干个子问题，然后再逐个求解，根据各个子问题得到的结果得到原问题的结果；
* 减治思想：在拆分子问题的时候，只将原问题转化成 **一个** 规模更小的子问题，因此子问题的结果就是上一层原问题的结果，每一步只需要解决一个规模更小的子问题，相比较于「分治思想」而言，它 **没有「合并」的过程**。

## 复杂度分析

**Master 定理：** 如果一个规模为 $n$ 的问题，可以拆解为 $a$ 个子问题，每个子问题的规模是 ${n} \over {b}$，其中 $a \geq 1$，$b>1$，用 $f(n)$ 表示分解和合并的开销与 $n$ 的关系，那么原始问题的时间复杂度 $T(n)$ 可以表示成如下递归式：

$$T(n) = a⋅T({{n} \over {b}}) + f(n)$$

$T(n)$ 可以通过如下方式求解：

* 如果 $f(n) < n ^ {\log_b a}$，那么 $T(n) = O(n ^ {\log_b a})$；
* 如果 $f(n) = n ^ {\log_b a}$，那么 $T(n) = O(n ^ {\log_b a}⋅\log n)$；
* 如果 $f(n) > n ^ {\log_b a}$，那么 $T(n) = O(f(n))$。

即比较 $f(n)$ 与 $n ^ {\log_b a}$ 的大小，如果相等，则 T(n) 等于 $n ^ {\log_b a}⋅\log n$。如果不相等，谁大就以谁作为时间复杂度，这一点与「时间复杂度考虑最差情况」的规则一致。

**eg 1. 利用 Master 定理求解「二分查找」的时间复杂度**

二分查找每次将问题一分为二，但是只在其中一个子问题里继续求解，此时 $a = 1$，$b = 2$。只有拆分子问题，不用合并子问题，此时 $f(n) = 1$（常数次操作，与 $n$ 无关）。比较 $n^{\log_{b}a} = n^{\log_{2}1} = n^{0} = 1$，套用 Master 定理的第二种情况，此时 $T(n) = O(\log n)$。

**eg 2. 利用 Master 定理求解「归并查找」的时间复杂度**

二分查找每次将问题一分为二，然后递归在两个子问题里继续求解，此时 $a = 2$，$b = 2$。拆分子问题使用了 $O(1)$，合并子问题使用了 $f(n) = n$，此时 $f(n) = n$。比较 $n^{\log_{b}a} = n^{\log_{2}2} = n$，套用主定理的第二种情况，此时 $T(n) = O(n \log n)$。

## 参考链接

* [分治法 - wiki](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95)
* [五大常用算法之一：分治算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html)
* [递归和分治精讲](https://leetcode-cn.com/leetbook/read/recursion-and-divide-and-conquer/rvhne3/)
