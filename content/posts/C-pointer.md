---
title: "C 指针学习"
date: 2021-3-31T20:15:00+08:00
draft: false
tags: ["C"]
slug: "C pointer learning"
---

该文章主要针对 **C 指针** 的系统学习。

目录：

- [复杂类型分析](#复杂类型分析)
- [指针概念](#指针概念)
- [指针的算术运算](#指针的算术运算)
- [运算符 & 和 *](#运算符--和-)
- [数组和指针的关系](#数组和指针的关系)
- [函数和指针的关系](#函数和指针的关系)
  - [函数指针](#函数指针)
  - [回调函数](#回调函数)
    - [定义](#定义)
    - [机制](#机制)
    - [意义](#意义)
    - [实现](#实现)
- [参考链接](#参考链接)

## 复杂类型分析

复杂类型同普通表达式一样，有优先级。**分析复杂类型时，可从变量名处起，根据运算符优先级结合，逐步分析。**

**复杂类型中运算符的优先级排序：`()` > `[]` > `*`。**

复杂类型分析：

* `int p;` - 普通的整型变量。
* `int *p;`
  * 首先从 `p` 处开始，先与 `*` 结合，所以说明 `p` 是一个指针；
  * 然后再与 `int` 结合，说明指针所指向的内容的类型为 `int` 型；
  * 所以 `p` 是一个返回整型数据的指针。
* `int p[3];`
  * 首先从 `p` 处开始，先与 `[]` 结合，说明 `p` 是一个数组；
  * 然后与 `int` 结合，说明数组里的元素是整型的；
  * 所以 `p` 是一个由整型数据组成的数组。
* `int *p[3];`
  * 首先从 `p` 处开始，先与 `[]` 结合，因为其优先级比 `*` 高，所以 `p` 是一个数组；
  * 然后再与 `*` 结合，说明数组里的元素是指针类型，然后再与 `int` 结合，说明指针所指向的内容的类型是整型的；
  * 所以 `p` 是一个由返回整型数据的指针所组成的数组。
* `int (*p)[3];`
  * 首先从 `p` 处开始，先与 `*` 结合，说明 `p` 是一个指针（`()`改变优先级）；
  * 然后再与 `[]` 结合，说明指针所指向的内容是一个数组，然后再与 `int` 结合，说明数组里的元素是整型的；
  * 所以 `p` 是一个指向由整型数据组成的数组的指针。
* `int **p;`
  * 首先从 `p` 开始，先与 `*` 结合，说明 `p` 是一个指针；
  * 然后再与 `*` 结合，说明指针所指向的元素是指针；
  * 然后再与 `int` 结合，说明该指针所指向的元素是整型数据。
  * 所以 `p` 是一个指向 `int *` 类型指针的指针。
* `int p(int);`
  * 从 `p` 处起，先与 `()` 结合，说明 `p` 是一个函数；
  * 然后进入 `()` 里分析，说明该函数有一个整型变量的参数；
  * 然后再与外面的 `int` 结合，说明函数的返回值是一个整型数据。
  * 所以 `p` 是一个有一个整型参数且返回类型为整形的函数。
* `int (*p)(int);`
  * 从 `p` 处开始，先与指针结合，说明 `p` 是一个指针；
  * 然后与 `()` 结合，说明指针指向的是一个函数；
  * 然后再与 `()` 里的 `int` 结合，说明函数有一个 `int` 型的参数；
  * 再与最外层的 `int` 结合，说明函数的返回类型是整型；
  * 所以 `p` 是一个指向有一个整型参数且返回类型为整型的函数的指针。
* `int *(*p(int))[3];`
  * 从 p 开始，先与 `()` 结合，说明 `p` 是一个函数；
  * 然后进入 `()` 里面，与 `int` 结合，说明函数有一个整型变量参数；
  * 然后再与外面的 `*` 结合，说明函数返回的是一个指针；
  * 然后到最外面一层，先与 `[]` 结合，说明返回的指针指向的是一个数组；
  * 然后再与 `*` 结合，说明数组里的元素是指针，然后再与 `int` 结合，说明指针指向的内容是整型数据；
  * 所以 `p` 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

> **注意：** 由上述分析可知，`*` 与变量名相结合构成指针，故出于规范 C\C++ 声明指针时应将 `*` 号紧挨变量名，以提高程序可读性。
>
> ```C++
> int *a;         // 规范 - 创建一个 int 型指针 a
> int* a;         // 不规范 - 创建一个 int 型指针 a
> int *a, b, c;   // 创建一个 int 型指针 a 和两个 int 型变量 b，c
> int *a, *b, *c; // 创建三个 int 型指针 a，b，c
> ```

## 指针概念

指针是一个特殊的变量，它里面存储的数值被解释为内存里的一个地址。

指针可分为以下四个方面内容：

* 指针的类型。
  * 将指针声明语句中的指针变量名去掉，剩下的部分便是该指针的类型。如：`int *ptr;` : 指针的类型是 `int *`。
* 指针所指向的类型。
  * 当通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待；
  * 从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符 `*` 去掉，剩下的就是指针所指向的类型。如：`int *ptr;` : 指针所指向的类型是 `int`；
  * 指针所指向的类型，将会影响指针的算术运算。如：`int *` 类型指针 `p`，执行 `p++` 时，将会把 `p` 的值加上 `sizeof(int)`。
* 指针的值或者叫指针所指向的内存区。
  * 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。
  * 指针所指向的内存区就是从指针的值所代表的内存地址开始，长度为 `sizeof(指针所指向的类型)` 的一块内存区。
* 指针本身所占据的内存区。
  * 指针本身所占的内存大小。通过 `sizeof(指针的类型)`，便可计算得出。

## 指针的算术运算

指针可以进行加减运算。指针的这种运算是以单元为单位。如：`int *` 类型指针 `p`，执行 `p++` 时，将会把 `p` 的值加上 `sizeof(int)`。

可以利用指针和循环来遍历一个数组：

示例：

```c
int array[20]={0};
int *ptr=array;
for(i=0;i<20;i++)
{
    (*ptr)++;
    ptr++；
}
```

## 运算符 & 和 *

`&` 是取地址运算符，`*` 是间接运算符。

`&a` 的运算结果是一个指针。

* 指针的类型是 `a` 的类型加个 `*`；
* 指针所指向的类型是 `a` 的类型；
* 指针所指向的地址是 `a` 的地址。

`*p` 也称 `p` 解引用，运算结果的类型是 `p` 所指向的类型。

* 类型是 `p` 指向的类型；
* 所占用的地址是 `p` 所指向的地址。

## 数组和指针的关系

数组名是指向数组中第一个元素的常量指针。

示例：

```c
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; //也可写成：value=*array;
value=array[3]; //也可写成：value=*(array+3);
value=array[4]; //也可写成：value=*(array+4);
```

## 函数和指针的关系

### 函数指针

函数指针是指向函数的指针变量，函数指针可以像一般函数一样，用于调用函数、传递参数。

函数指针变量的声明：

```c
int (*fun_ptr)(int,int);  // 函数返回值类型 (*指针变量名) (函数参数列表);
```

实例：

以下实例声明了函数指针变量 `p`，并使其指向函数 `max`：

```c
#include <stdio.h>
 
int max(int x，int y)
{
    return x > y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int，int) = & max; // &可以省略
   
    ......
 
    /* 与直接调用函数等价，d = max(max(a，b)，c) */
    d = p(p(a，b)，c); 
 
    ......
 
    return 0;
}
```

### 回调函数

#### 定义

回调函数就是一个被作为参数传递的函数，在 C 语言中，回调函数由函数指针实现，故也可认为是通过函数指针调用的函数。

#### 机制

1. 定义一个回调函数；
2. 提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；
3. 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。

#### 意义

**降低耦合度。**

通过回调函数，可以把调用者与被调用者分开，调用者可以不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的被调用函数。简而言之，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。（某种程度上与 Java 面向对象中的多态概念和控制反转-IoC 有异曲同工之妙）

#### 实现

```c
#include<stdio.h>

int Callback_1() // Callback Function 1
{
    printf("Hello，this is Callback_1 ");
    return 0;
}

int Callback_2() // Callback Function 2
{
    printf("Hello，this is Callback_2 ");
    return 0;
}

int Callback_3() // Callback Function 3
{
    printf("Hello，this is Callback_3 ");
    return 0;
}

int Handle(int (*Callback)())
{
    printf("Entering Handle Function. ");
    Callback();
    printf("Leaving Handle Function. ");
}

int main()
{
    printf("Entering Main Function. ");
    Handle(Callback_1);
    Handle(Callback_2);
    Handle(Callback_3);
    printf("Leaving Main Function. ");
    return 0;
}
```

运行结果：

```
Entering Main Function.
Entering Handle Function.
Hello，this is Callback_1
Leaving Handle Function.
Entering Handle Function.
Hello，this is Callback_2
Leaving Handle Function.
Entering Handle Function.
Hello，this is Callback_3
Leaving Handle Function.
Leaving Main Function.
```

## 参考链接

* [C 指针详解](https://www.runoob.com/w3cnote/c-pointer-detail.html)
* [C 语言 | 菜鸟教程](https://www.runoob.com/cprogramming/c-tutorial.html)
* [回调函数](https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin)
