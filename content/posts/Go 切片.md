---
title: "Go 切片"
date: 2022-03-09T23:32:00+08:00
draft: false
tags: ["Go"]
slug: "Go slice"
---

切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。因为切片的底层内存也是在连续块中分配的，所以切片能获得索引、迭代以及为垃圾回收优化的好处。

**内部实现：**

切片对底层数组进行了抽象，并提供相关的操作方法。切片有 3 个字段的数据结构，这些结构包含 Go 语言操作底层数组的元数据：

* 指向底层数组的指针；
* 切片的长度（可访问的元素的个数）；
* 切片的容量（允许增长到的元素个数）。

目录：

- [声明及初始化](#声明及初始化)
- [基本操作](#基本操作)
  - [基础操作](#基础操作)
  - [使用切片创建切片](#使用切片创建切片)
  - [切片增长](#切片增长)
- [遍历切片](#遍历切片)
  - [一维切片](#一维切片)
  - [二维切片](#二维切片)
- [函数传递](#函数传递)
- [参考资料](#参考资料)

## 声明及初始化

**一维切片：**

```go
/* eg 1. make */

// 使用长度声明一个 int 切片，此时切片长度和容量相等
slice := make([]int, 5)

// 使用长度和容量声明 int 切片，注意：不能声明容量小于长度的切片
slice := make([]int, 3, 5)

/* eg 2. 切片字面量 */

// 创建 int 切片，其长度和容量都是 3
slice := []int{10, 20, 30}

// 创建 int 切片，其长度和容量都是 100
slice := []int{99:0}

// 注意：如果在 [] 运算符中指定了一个值，那么创建的就是数组而不是切片。
slice := [3]int{1, 2, 3} // 创建有 3 个元素的 int 数组
slice := []int{1, 2, 3}  // 创建长度和容量都是 3 的 int 切片

/* eg 3. nil 和 空切片 */

// 创建 nil 切片，常用于描述一个不存在的切片
// slice == nil && len(slice) == 0
var slice []int

// 声明空切片，常用于表示空集合
// slice != nil && len(slice) == 0
slice := make([]int, 0)
slice := []int{}

// 注意：不管是 nil 还是 空切片，对其调用内置函数 append、len 和 cap 效果都是一样的。
```

**多维切片：**

```go
/* 声明 3 * 4 的二维切片 */

// eg 1
ss := make([][4]int, 3)

// eg 2
ss := [][]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}

// eg 3
var ss [3][4]int

// eg 4
ss := make([][]int, 3)
for i := range ss {
	ss[i] = make([]int, 4)
}
```

## 基本操作

### 基础操作

```go
// 返回切片的长度
len(slice)

// 返回切片的容量
cap(slice)
```

**注意：** 判断切片是否为空用 `len(slice) == 0`，而不是将其与 `nil` 比较。

### 使用切片创建切片

```go
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
```

**注意：** 这两个切片共享同一段底层数组，但不同的切片会看到不同的部分。

对于底层数组容量是 `k` 的切片 `slice[i:j]` 来说：

* 长度：j - i
* 容量：k - i

在创建切片时，还可以使用第 3 个索引选项，用来控制新切片的容量。

```go
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[2:3:4]
```

**Tips:** 如果在创建切片时设置切片的容量和长度一样 `newSlice := slice[2:3:3]`，就可以强制让新切片第一个 `append` 操作创建新的底层数组，与原数组分离，从而安全地进行后续修改。

### 切片增长

通过函数 `append` 向切片追加值，函数 `append` 总是会增加新切片的长度，而容量有可能会改变，也可能不会改变（视切片可用容量而定）。

```go
slice := []int{10, 20, 30, 40}
slice = append(slice, 50)
```

* 如果切片在底层数组还有额外的容量可用，则 `append` 操作会将可用的元素合并到切片的长度，并对其进行赋值。
* 如果切片没有足够的可用容量，`append` 操作会创建一个新的底层数组，将被引用的现有的值复制到新数组中，再追加新的值。
  * `append` 会智能地处理底层数组的容量增长。在切片容量小于 1000 时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25。

`append` 是一个可变参数的函数，其可以在一次调用传递多个追加的值。如果使用 `...` 运算符，可以将一个切片的所有元素追加到另一个切片里。

```go
s1 := []int{1, 2}
s2 := []int{3, 4}
s3 := append(s1, s2...) // 1 2 3 4
```

**扩展操作：**

```go
// push back
a = append(a, x)

// pop back
x, a = a[len(a)-1], a[:len(a)-1]

// push front
a = append([]T{x}, a...)

// pop front
x, a = a[0], a[1:]

// 删除元素 [i, j)
a = append(a[:i], a[j:]...)

// 内部扩张
a = append(a[:i], append(make([]T, j), a[i:]...)...)

// 尾部扩张
a = append(a, make([]T, j)...)

// insert - 将元素 x 插入切片 a 的索引 i 处
a = append(a, 0 /* 这里应使用元素类型的零值 */)
copy(a[i+1:], a[i:])
a[i] = x
```

## 遍历切片

### 一维切片

**eg 1.1 下标 for 循环遍历**

```go
for i := 0; i < len(slice); i++ {
	fmt.Println(slice[i])
}
```

**eg 1.2 基于 range 的 for 循环遍历**

```go
for idx, val := range slice {
	fmt.Println(idx, val)
}
```

### 二维切片

**eg 2.1 下标 for 循环遍历**

```go
slice := [][]int{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}
for i := 0; i < len(slice); i++ {
	for j := 0; j < len(slice[i]); j++ {
		fmt.Println(slice[i][j])
	}
}
```

**eg 2.2 基于 range 的 for 循环遍历**

```go
for idx1, val1 := range slice {
	for idx2, val2 := range val1 {
		fmt.Println(idx1, idx2, val2)
	}
}
```

## 函数传递

```go
// 分配包含 1e6 个整形值的切片
slice := make([]int, 1e6)

// 将 slice 传递到函数 foo
slice = foo(slice)

// 函数 foo 接收一个整形切片，并返回切片
func foo(slice []int) []int {
    ......
    return slice
}
```

在函数间传递切片，等价于在函数间以值的方式传递切片，由于切片的尺寸很小，所以在函数间复制和传递切片的代价也很低。在 64 位机器上，一个切片需要 `24` 字节的内存：

* 指针 8 字节
* 长度 8 字节
* 容量 8 字节

**将切片传递给任意函数时，只会复制切片本身，不会涉及底层数组。**

## 参考资料

* 《Go 语言实战》
* [关于切片操作的技巧](https://www.liwenzhou.com/posts/Go/slice_tricks/)
